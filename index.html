<!DOCTYPE html>
<html lang="en">
<head>
    <title>purpledeni</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="style.css">
	<meta name="darkreader-lock">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="container">
    	<img src="svg/purpledeni.svg" alt="Deni Logo" style="width: 360px"/>
    	<img src="svg/purpledeni_text.svg" alt="Deni Logo Text" style="width: 800px; margin-top: -50px"/>
		<p style="color: white; font-family: JetBrains; font-size: 20px">Work in Progress...</p>
		<div class="buttons">
			<a class="link" href="https://ko-fi.com/purpledeni">
				<img src="svg/kofi.svg" alt="Kofi Button"/>
			</a>
			<a class="link" href="https://bsky.app/profile/purpledeni.ink">
				<img src="svg/bsky.svg" alt="Bluesky Button"/>
			</a>
			<a class="link" href="https://github.com/purpledeni">
				<img src="svg/github.svg" alt="Github Button"/>
			</a>
			<a class="link" href="https://www.youtube.com/@purpledeni">
				<img src="svg/youtube.svg" alt="YouTube Button"/>
			</a>
		</div>
		<div class="credit">
			<p>Background Shader by <a style="color: #ffffff7f;" href="https://www.shadertoy.com/view/WXjcRR">belisoful</a></p>
		</div>
	</div>
    

<script>
const vertexSrc = `
attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const fragmentSrc = `
precision mediump float;

uniform float iTime;
uniform vec2 iResolution;


void mainImage(out vec4 o, vec2 v)
{
    // empty color
    o = vec4(0.0);
    
    // resolution for math
    o.xy = iResolution.xy;

    // screen coordinates
    vec2 u = (v + v - (o.xy)) / o.y;
    
    // squash stretch
    u /= 0.5 + 0.2 * dot(u, u);
    
    // motion shift
    u += 0.2 * cos(iTime) - 7.56;

    // loop color channels
    for (int i = 0; i < 3; i++) {
        // move coordinate pattern first
        u -= 0.01;
        v = sin(1.5 * u.yx + 2.0 * cos(u));
    
        // color intensity based on sine motion
        float comp = 1.0 - exp(-6.0 / exp(6.0 * length(v + sin(5.0 * v.y - 3.0 * iTime + float(i)) / 4.0)));
    
        // assign channels
        if (i == 0) o.r = comp;
        else if (i == 1) o.g = comp;
        else o.b = comp;
    }


    // alpha
    o.rgb = pow(o.rgb, vec3(1.0));  // <-- fun to play with :3
    o.a = 1.0;
}


void main() {

    // pixel position
    vec2 fragCoord = gl_FragCoord.xy;

    // output color
    vec4 outCol;

    // call main
    mainImage(outCol, fragCoord);

    gl_FragColor = outCol;
    
}
`;



const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl', {
    alpha: true,
    premultipliedAlpha: false
});

if (!gl) {
    alert('WebGL not supported 3:');
    throw new Error('WebGL not supported 3:');
}

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
}

const positions = new Float32Array([
   -1, -1,
    1, -1,
   -1,  1,
    1,  1,
]);

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// uniform locations
const timeLocation = gl.getUniformLocation(program, 'iTime');
const resolutionLocation = gl.getUniformLocation(program, 'iResolution');


function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}

resize();
window.addEventListener('resize', resize);

// loop
const startTime = Date.now();

function render() {
    const currentTime = (Date.now() - startTime) * 0.001;

    gl.useProgram(program);
    gl.uniform1f(timeLocation, currentTime);
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    requestAnimationFrame(render);
}

render();
</script>

</body>
</html>